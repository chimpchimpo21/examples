<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
        <title> Cylinder AR test </title>
    </head>
    <body>
        <pre id="info" style="font-family: monospace; font-size: 14px; white-space: pre; color: #F9203A;">Cylinder in AR</pre>

        <script type="module">

            const info = document.getElementById("info");

            //THREE.js scripts imports
            
            import * as THREE from 'https://cdn.skypack.dev/three@0.128.0/build/three.module.js';
            import { ARButton} from 'https://cdn.skypack.dev/three@0.128.0/examples/jsm/webxr/ARButton.js';

            var container, camera, scene, renderer;

            // testing offset variable

            var offset;

            init();
            animate();

            function init() {

                // geometry attributes
                var my_location = [0, 0, 0];
                var p1 = [5,-3,-1.5];
                var p2 = [-15,-3,-1.5];
                var midpoint = [ (p1[0]+p2[0])/2, (p1[1]+p2[1])/2 ];
                var a2 = Math.sqrt( Math.pow( ( p2[0] - midpoint[0] ), 2 ) + Math.pow( ( p2[1] - midpoint[1] ), 2) );
                var b2 = Math.sqrt( Math.pow( ( p2[0] - my_location[0] ), 2 ) + Math.pow( ( p2[1] - my_location[1] ), 2) );
                var c2 = Math.sqrt( Math.pow( ( midpoint[0] - my_location[0] ), 2 ) + Math.pow( ( midpoint[1] - my_location[1] ), 2) );
                var a = Math.sqrt(Math.pow((p2[0]-p1[0]), 2)+Math.pow((p2[1]-p1[1]), 2));
                var b = Math.sqrt(Math.pow((p2[0]-my_location[0]), 2)+Math.pow((p2[1]-my_location[1]), 2));
                var c = Math.sqrt(Math.pow((p1[0]-my_location[0]), 2)+Math.pow((p1[1]-my_location[1]), 2));


                var p3 = [-15, -1.5, -7];
                var p4 = [-15, -1.5, 4];
                var midpoint2 = [ (p3[0]+p4[0])/2, (p3[1]+p4[1])/2, (p3[2]+p4[2])/2 ];
                var length2 = Math.sqrt( Math.pow((p4[0]-p3[0]), 2) + Math.pow((p4[2]-p3[2]), 2) );



                var cos = (Math.pow(b, 2) + Math.pow(c, 2) - Math.pow(a, 2))/(2*b*c);
                var newCos = (Math.pow(b, 2) + Math.pow(c, 2) - Math.pow(a, 2))/(2*b*c);
                var arccos = Math.acos(cos);

                // cylinder attributes

                function startup() {
                    window.addEventListener("touchend", checkOrientation, false);
                }
                

                container = document.createElement( 'div' );
                document.body.appendChild( container );

                // Scene

                scene = new THREE.Scene();
                
                // Camera

                camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 50 );
                
                // Renderer

                renderer = new THREE.WebGLRenderer( { antialias: true, alpha: true } );
                renderer.setPixelRatio( window.devicePixelRatio );
                renderer.setSize( window.innerWidth, window.innerHeight );
                renderer.xr.enabled = true;
                container.appendChild( renderer.domElement );

                // AR Button

                document.body.appendChild( ARButton.createButton( renderer, { 
                    optionalFeatures: [ 'dom-overlay', 'dom-overlay-for-handheld-ar' ],
                    domOverlay: { root: document.body }
                }));

                // Directional light

                const color = 0xffffff;
                const intensity = 1;
                const light = new THREE.DirectionalLight( color, intensity );
                light.position.set( 0, 10, 0 );
                scene.add(light); 

                // Cylinder properties

                const cylProps = { transparent: false,
                                   opacity: 0.85,
                                   alphaTest: 0.2,
                                   color: 0x049ef4,
                                   specular: 0x363030,
                                   shininess: 45,
                                   side: THREE.DoubleSide }
                
                // var cylinderHeight = Math.abs(p2[0]-p1[0]);
                var cylinderHeight = 20;

                const geometry = new THREE.CylinderBufferGeometry( 0.3, 0.3, Math.abs(p2[0]-p1[0]), 32, 1, true );
                const geometry2 = new THREE.CylinderBufferGeometry( 0.3, 0.3, length2, 32, 1, true );
                geometry.translate( 0, cylinderHeight/2, 0 );
                const material = new THREE.MeshPhongMaterial( cylProps );
                const cylinder = new THREE.Mesh( geometry, material );
                const cylinder2 = new THREE.Mesh( geometry2, material )

                // Check for device orientation - TESTING

                // handle iOS orientation

                function handleiOSOrientation(event) {

                    var compassDir = event.webkitCompassHeading;
                    if (compassDir === 0) {
                        checkOrientation();
                    }
                    info.textContent = `compass heading: ${compassDir}`;
                    offset = compassDir * (Math.PI/180);

                    // cylinder.position.set( (p1[0]+p2[0])/2, p1[2], (p1[1]+p2[1])/2 );
                    cylinder.position.set( p2[0], p2[1], p2[2]);
                    cylinder2.position.set( midpoint2[0], midpoint2[1], midpoint2[2] );

                    // cylinder.rotation.x = Math.PI / 2;
                    


                    cylinder2.rotation.x = Math.PI / 2;
                    // cylinder.lookAt(p1);
                    // cylinder.rotation.z = -Math.PI / 2;
                    // cylinder.rotation.z = -arccos;
                    // cylinder.rotation.z = -arccos;
                    
                    scene.add( cylinder );
                    scene.add( cylinder2 );

                }
                // scene.rotation.y += -offset;
                // handle Android orientation

                function handleOrientation(event) {

                    var z = event.alpha; // In degree in the range (0, 360)
                    var a = event.absolute; //boolean of whether orientation data is absolute or relative

                    console.log(z, a);
                    
                }

                document.addEventListener("DOMContentLoaded", startup);

                function checkOrientation() {
                    const options = {
                        once: true
                    }
                    if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                        DeviceOrientationEvent.requestPermission()
                        .then(permissionState => {
                            if (permissionState === 'granted') {
                                // info.textContent = 'iPhone';
                                window.addEventListener('deviceorientation', handleiOSOrientation, options);
                            }
                        })
                        .catch(console.error);
                    } else {
                        info.textContent = 'Android';
                        window.addEventListener('deviceorientation', handleOrientation, true);
                    }
                }

                // Controller

                // controller = renderer.xr.getController( 0 );
                // scene.add( controller );

                
                // cylinder.rotation.x = Math.PI / 2;
                // cylinder.rotation.z = offset;
                // cylinder.position.set( 0, -3, -3 );
                // cylinder.position.set( 0, -3, -3 ).applyMatrix4( controller.matrixWorld );
                // cylinder.quaternion.setFromRotationMatrix( controller.matrixWorld );
                // scene.add( cylinder );

                // Window resize listener

                window.addEventListener( 'resize', onWindowResize, false);
            }

            function onWindowResize() {

                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize( window.innerWidth, window.innerHeight );
            }

            function animate() {
                
                renderer.setAnimationLoop( render );
                
            }

            function render() {
                
                renderer.render( scene, camera );
            }

        </script>
    </body>
</html>