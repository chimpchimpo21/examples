<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
        <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.8.0/proj4.min.js" integrity="sha512-pLnzlcFjcj9A9ggTfXZyscd+BWAV9pHdDrLekEoTimItxZI3uOAi7CSLXAHGZu7zRgG9Xyhl9bG3A1uRSJJOJg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script src="pipes.js"></script>
        <title> Cylinder AR test </title>
    </head>
    <body>
        <pre id="info" style="font-family: monospace; font-size: 14px; white-space: pre; color: #F9203A;">Cylinder in AR</pre>

        <script type="module">

            const info = document.getElementById("info");

            //THREE.js scripts imports
            
            import * as THREE from 'https://cdn.skypack.dev/three@0.128.0/build/three.module.js';
            import { ARButton} from 'https://cdn.skypack.dev/three@0.128.0/examples/jsm/webxr/ARButton.js';

            // THREE.js scene variables

            var container, camera, scene, renderer;

            // testing offset variable

            var offset;

            init();
            animate();

            function init() {
                
                // geometry attributes
                var my_location = [0, 0, 0];
                var p1 = [5,-3,-1.5];
                var p2 = [-15,-3,-1.5];
                var midpoint = [ (p1[0]+p2[0])/2, (p1[1]+p2[1])/2 ];
                var a2 = Math.sqrt( Math.pow( ( p2[0] - midpoint[0] ), 2 ) + Math.pow( ( p2[1] - midpoint[1] ), 2) );
                var b2 = Math.sqrt( Math.pow( ( p2[0] - my_location[0] ), 2 ) + Math.pow( ( p2[1] - my_location[1] ), 2) );
                var c2 = Math.sqrt( Math.pow( ( midpoint[0] - my_location[0] ), 2 ) + Math.pow( ( midpoint[1] - my_location[1] ), 2) );
                var a = Math.sqrt(Math.pow((p2[0]-p1[0]), 2)+Math.pow((p2[1]-p1[1]), 2));
                var b = Math.sqrt(Math.pow((p2[0]-my_location[0]), 2)+Math.pow((p2[1]-my_location[1]), 2));
                var c = Math.sqrt(Math.pow((p1[0]-my_location[0]), 2)+Math.pow((p1[1]-my_location[1]), 2));

                // test vectors
                var vec1 = new THREE.Vector3( 5, -3, -1.5 );
                var vec2 = new THREE.Vector3( -15, -3, -1.5 );
                var vecLen = vec2.distanceTo(vec1);
                var angle = vec1.angleTo(vec2);
                console.log(angle, vecLen);


                var p3 = [-15, -3, -7];
                var p4 = [-15, -3, 4];
                var vec3 = new THREE.Vector3( -15, -3, -7 );
                var vec4 = new THREE.Vector3( -15, -3, 4 );
                var vecLen2 = vec3.distanceTo(vec4);
                var midpoint2 = [ (p3[0]+p4[0])/2, (p3[1]+p4[1])/2, (p3[2]+p4[2])/2 ];
                var length2 = Math.sqrt( Math.pow((p4[0]-p3[0]), 2) + Math.pow((p4[2]-p3[2]), 2) );



                var cos = (Math.pow(b, 2) + Math.pow(c, 2) - Math.pow(a, 2))/(2*b*c);
                var newCos = (Math.pow(b, 2) + Math.pow(c, 2) - Math.pow(a, 2))/(2*b*c);
                var arccos = Math.acos(cos);

                // fake pipe data prep
                // reproject pipe start/end coordinates from WGS84 to Spherical Mercator
                var firstProjection = "EPSG:3857";
                
                var pipe1StartCoords = proj4( firstProjection, pipes.features[0].geometry.coordinates[0] );
                var pipe1EndCoords = proj4( firstProjection, pipes.features[0].geometry.coordinates[1] );
                var pipe2StartCoords = proj4( firstProjection, pipes.features[1].geometry.coordinates[0] );
                var pipe2EndCoords = proj4( firstProjection, pipes.features[1].geometry.coordinates[1] );

                // Create Vector3 objects for each pipe end (have to manually add -5 meters for y-axis for now b/c pipe data does not have z-value)

                var pipe1Start = new THREE.Vector3( pipe1StartCoords[0], -5, pipe1StartCoords[1] );
                var pipe1End = new THREE.Vector3( pipe1EndCoords[0], -5, pipe1EndCoords[1] );
                var pipe2Start = new THREE.Vector3( pipe2StartCoords[0], -5, pipe2StartCoords[1] );
                var pipe2End = new THREE.Vector3( pipe2EndCoords[0], -5, pipe2EndCoords[1] );

                // Calculate pipe lengths

                var pipe1Length = pipe1Start.distanceTo( pipe1End );
                var pipe2Length = pipe2Start.distanceTo( pipe2End );
                // console.log(pipe1StartCoords, pipe1EndCoords);
                // cylinder attributes

                // listener for checking device orientation, should occur when "Start AR" is first tapped
                function startup() {
                    window.addEventListener("touchend", checkOrientation, false);
                }

                // scene DOM container

                container = document.createElement( 'div' );
                document.body.appendChild( container );

                // Scene

                scene = new THREE.Scene();
                
                // Camera

                camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 250 );
                
                // Renderer

                renderer = new THREE.WebGLRenderer( { antialias: true, alpha: true } );
                renderer.setPixelRatio( window.devicePixelRatio );
                renderer.setSize( window.innerWidth, window.innerHeight );
                renderer.xr.enabled = true;
                container.appendChild( renderer.domElement );

                // AR Button

                document.body.appendChild( ARButton.createButton( renderer, { 
                    optionalFeatures: [ 'dom-overlay', 'dom-overlay-for-handheld-ar' ],
                    domOverlay: { root: document.body }
                }));

                // Directional light

                const color = 0xffffff;
                const intensity = 1;
                const light = new THREE.DirectionalLight( color, intensity );
                light.position.set( 0, 10, 0 );
                scene.add(light); 

                // Cylinder properties

                const cylProps = { transparent: false,
                                   opacity: 0.85,
                                   alphaTest: 0.2,
                                   color: 0x049ef4,
                                   specular: 0x363030,
                                   shininess: 45,
                                   side: THREE.DoubleSide }

                // Cylinder creation

                const geometry = new THREE.CylinderBufferGeometry( 0.3, 0.3, pipe1Length, 32, 1, true );
                const geometry2 = new THREE.CylinderBufferGeometry( 0.3, 0.3, pipe2Length, 32, 1, true );
                geometry.translate( 0, pipe1Length/2, 0 );
                geometry2.translate( 0, pipe2Length/2, 0 );
                const material = new THREE.MeshPhongMaterial( cylProps );
                const cylinder = new THREE.Mesh( geometry, material );
                const cylinder2 = new THREE.Mesh( geometry2, material )

                // Check for device orientation - TESTING

                // handle iOS orientation

                function handleiOSOrientation(event) {

                    var compassDir = event.webkitCompassHeading;
                    if (compassDir === 0) {
                        checkOrientation();
                    }
                    info.textContent = `compass heading: ${compassDir}`;
                    offset = compassDir * (Math.PI/180);

                    // Cylinder Positioning Tests

                    cylinder.position.set( pipe1Start.x, pipe1Start.y, pipe1Start.z );
                    cylinder2.position.set( pipe2Start.x, pipe2Start.y, pipe2Start.z );

                    const axis = new THREE.Vector3( pipe1Start.x-pipe1End.x, pipe1Start.y-pipe1End.y, pipe1Start.z-pipe1End.z ).normalize();
                    const axis2 = new THREE.Vector3( pipe2Start.x-pipe2End.x, pipe2Start.y-pipe2End.y, pipe2Start.z-pipe2End.z ).normalize();

                    const quaternion = new THREE.Quaternion();
                    const quaternion2 = new THREE.Quaternion();
                    const cylinderUpAxis = new THREE.Vector3( 0, 1, 0 );
                    
                    quaternion.setFromUnitVectors( cylinderUpAxis, axis );
                    quaternion2.setFromUnitVectors( cylinderUpAxis, axis2 );
                    cylinder.applyQuaternion(quaternion);
                    cylinder2.applyQuaternion(quaternion2);

                    // cylinder2.rotation.x = Math.PI / 2;
                    // cylinder.lookAt(5, -3, -1.5);  does not point towards p1, possibly rotates cylinder barrel towards p1
                    // cylinder.rotation.z = -Math.PI / 2;
                    // cylinder.rotation.z = -arccos;
                    // cylinder.rotation.z = -arccos;
                    
                    scene.add( cylinder );
                    scene.add( cylinder2 );
                    // scene.add( cylinder2 );
                }
                scene.rotation.y += -offset;
                // handle Android orientation

                function handleOrientation(event) {

                    var z = event.alpha; // In degree in the range (0, 360)
                    var a = event.absolute; //boolean of whether orientation data is absolute or relative

                    console.log(z, a);
                    
                }

                document.addEventListener("DOMContentLoaded", startup);

                function checkOrientation() {
                    const options = {
                        once: true
                    }
                    if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                        DeviceOrientationEvent.requestPermission()
                        .then(permissionState => {
                            if (permissionState === 'granted') {
                                // info.textContent = 'iPhone';
                                window.addEventListener('deviceorientation', handleiOSOrientation, options);
                            }
                        })
                        .catch(console.error);
                    } else {
                        info.textContent = 'Android';
                        window.addEventListener('deviceorientation', handleOrientation, true);
                    }
                }

                // Controller

                // controller = renderer.xr.getController( 0 );
                // scene.add( controller );

                // Window resize listener

                window.addEventListener( 'resize', onWindowResize, false);
            }

            function onWindowResize() {

                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize( window.innerWidth, window.innerHeight );
            }

            function animate() {
                
                renderer.setAnimationLoop( render );
                
            }

            function render() {
                
                renderer.render( scene, camera );
            }

        </script>
    </body>
</html>